import{C as S,g as _,cI as F,b as T,cJ as f,m as C,B as c,cK as I,ar as O,cL as R,al as k,cM as U,cN as H,cO as B,cP as K,aX as V,cQ as G,cR as E,cS as W,h as D,_ as L,cT as $,cU as M,cV as z,cW as j,b6 as A,at as P,f as J,cc as Y,cH as q,cX as X,K as Z,cY as Q,cZ as tt,c_ as et}from"./index-xaRlz1rn.js";import{i as N}from"./url-a45219bd.browser.esm-N2MoeX-p.js";async function v(o){const t=await f(o);return Object.keys(t).map(a=>{let e=t[a];return(typeof e!="string"||!e.startsWith("0x"))&&(e=D(e)),[a,e]}).reduce((a,e)=>{let[s,n]=e;return{...a,[s]:n}},{})}async function at(o,t,a){const e=await f(o),s={sender:e.sender,nonce:e.nonce,initCodeHash:A(e.initCode),callDataHash:A(e.callData),callGasLimit:e.callGasLimit,verificationGasLimit:e.verificationGasLimit,preVerificationGas:e.preVerificationGas,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,paymasterAndDataHash:A(e.paymasterAndData)},n={components:[{type:"address",name:"sender"},{type:"uint256",name:"nonce"},{type:"bytes32",name:"initCodeHash"},{type:"bytes32",name:"callDataHash"},{type:"uint256",name:"callGasLimit"},{type:"uint256",name:"verificationGasLimit"},{type:"uint256",name:"preVerificationGas"},{type:"uint256",name:"maxFeePerGas"},{type:"uint256",name:"maxPriorityFeePerGas"},{type:"bytes32",name:"paymasterAndDataHash"}],name:"hashedUserOp",type:"tuple"},r=P.encode([n],[{...s}]),i=A(r),d=P.encode(["bytes32","address","uint256"],[i,t,a]);return A(d)}const st=()=>{const o=BigInt(Math.floor(Math.random()*4294967296)),t=BigInt(Math.floor(Math.random()*4294967296)),a=BigInt(Math.floor(Math.random()*4294967296)),e=BigInt(Math.floor(Math.random()*4294967296)),s=BigInt(Math.floor(Math.random()*4294967296)),n=BigInt(Math.floor(Math.random()*4294967296));return o<<BigInt(160)|t<<BigInt(128)|a<<BigInt(96)|e<<BigInt(64)|s<<BigInt(32)|n},b=()=>{let o=st().toString(16);return o.length%2!==0&&(o="0"+o),o="0x"+o,c.from(et([o,"0x0000000000000000"]))};class rt{}class nt{constructor(t,a,e,s,n){this.bundlerUrl=t,this.entryPointAddress=a,this.chainId=e;const r={};if(N(this.bundlerUrl)){const i=typeof globalThis<"u"&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;n?r["x-secret-key"]=n:s&&(r["x-client-id"]=s,i&&(r["x-bundle-id"]=i)),typeof globalThis<"u"&&"TW_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_AUTH_TOKEN=="string"&&(r.authorization=`Bearer ${globalThis.TW_AUTH_TOKEN}`),typeof globalThis<"u"&&"TW_CLI_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_CLI_AUTH_TOKEN=="string"&&(r.authorization=`Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`,r["x-authorize-wallet"]="true"),G(r)}this.userOpJsonRpcProvider=new E({url:this.bundlerUrl,headers:r},{name:"Connected bundler network",chainId:e}),this.initializing=this.validateChainId()}async validateChainId(){const t=await this.userOpJsonRpcProvider.send("eth_chainId",[]),a=parseInt(t);if(a!==this.chainId)throw new Error(`bundler ${this.bundlerUrl} is on chainId ${a}, but provider is on chainId ${this.chainId}`)}async sendUserOpToBundler(t){await this.initializing;const a=await v(t),e=[a,this.entryPointAddress];return await this.printUserOperation("eth_sendUserOperation",e),await this.userOpJsonRpcProvider.send("eth_sendUserOperation",[a,this.entryPointAddress])}async estimateUserOpGas(t){await this.initializing;const a=await v(t),e=[a,this.entryPointAddress];return await this.printUserOperation("eth_estimateUserOperationGas",e),await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas",[a,this.entryPointAddress])}async printUserOperation(t,a){}}class it extends rt{constructor(t,a,e,s){super(),this.paymasterUrl=t,this.entryPoint=a,this.clientId=e,this.secretKey=s}async getPaymasterAndData(t){var n;const a={"Content-Type":"application/json"};if(N(this.paymasterUrl)){if(this.secretKey&&this.clientId)throw new Error("Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.");this.secretKey?a["x-secret-key"]=this.secretKey:this.clientId&&(a["x-client-id"]=this.clientId,typeof globalThis<"u"&&"APP_BUNDLE_ID"in globalThis&&(a["x-bundle-id"]=globalThis.APP_BUNDLE_ID)),typeof globalThis<"u"&&"TW_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_AUTH_TOKEN=="string"&&(a.authorization=`Bearer ${globalThis.TW_AUTH_TOKEN}`),typeof globalThis<"u"&&"TW_CLI_AUTH_TOKEN"in globalThis&&typeof globalThis.TW_CLI_AUTH_TOKEN=="string"&&(a.authorization=`Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`,a["x-authorize-wallet"]="true"),G(a)}const e=await fetch(this.paymasterUrl,{method:"POST",headers:a,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[await v(t),this.entryPoint]})}),s=await e.json();if(!e.ok){const r=s.error||e.statusText,i=s.code||"UNKNOWN";throw new Error(`Paymaster error: ${r}
Status: ${e.status}
Code: ${i}`)}if(s.result)return typeof s.result=="string"?{paymasterAndData:s.result}:s.result;{const r=((n=s.error)==null?void 0:n.message)||s.error||e.statusText||"unknown error";throw new Error(`Paymaster error from ${this.paymasterUrl}: ${r}`)}}}const ot=(o,t,a,e)=>new it(o,t,a,e);class x{constructor(t,a,e,s,n,r,i){this.resolve=t,this.reject=a,this.entryPoint=e,this.sender=s,this.userOpHash=n,this.nonce=r,this.timeout=i,L(this,"resolved",!1),this.boundLisener=this.listenerCallback.bind(this)}start(){const t=this.entryPoint.filters.UserOperationEvent(this.userOpHash);setTimeout(async()=>{const a=await this.entryPoint.queryFilter(t,-10);a.length>0?this.listenerCallback(a[0]):this.entryPoint.once(t,this.boundLisener)},100)}stop(){this.entryPoint.off("UserOperationEvent",this.boundLisener)}async listenerCallback(){var r;for(var t=arguments.length,a=new Array(t),e=0;e<t;e++)a[e]=arguments[e];const s=arguments[arguments.length-1];if(!s.args){console.error("got event without args",s);return}if(s.args.userOpHash!==this.userOpHash){console.log(`== event with wrong userOpHash: sender/nonce: event.${s.args.sender}@${s.args.nonce.toString()}!= userOp.${this.sender}@${parseInt((r=this.nonce)==null?void 0:r.toString())}`);return}const n=await s.getTransactionReceipt();s.args.success||await this.extractFailureReason(n),this.stop(),this.resolve(n),this.resolved=!0}async extractFailureReason(t){t.status=0;const a=await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash,this.sender),t.blockHash);if(a[0]){let e=a[0].args.revertReason;e.startsWith("0x08c379a0")&&(e=P.decode(["string"],"0x"+e.substring(10)).toString()),this.reject(new Error(`UserOp failed with reason: ${e}`))}}}class ct extends J{constructor(t,a,e,s,n){super(),Y(this,"provider",e),this.config=t,this.originalSigner=a,this.erc4337provider=e,this.httpRpcClient=s,this.smartAccountAPI=n}async sendTransaction(t,a){var d;const e=await f(t);await this.verifyAllNecessaryFields(e);const s=b(),n=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:e.to||"",data:((d=e.data)==null?void 0:d.toString())||"0x",value:e.value,gasLimit:e.gasLimit,nonce:s,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas},a),r=await this.smartAccountAPI.signUserOp(n),i=await this.erc4337provider.constructUserOpTransactionResponse(r);try{await this.httpRpcClient.sendUserOpToBundler(r)}catch(l){throw this.unwrapError(l)}return i}unwrapError(t){var a,e;try{let s="Unknown Error";if(t.error)s=`The bundler has failed to include UserOperation in a batch: ${t.error}`;else if(t.body&&typeof t.body=="string"){const r=JSON.parse(t.body),i=t.status||"UNKNOWN",d=(r==null?void 0:r.code)||"UNKNOWN";let l=((a=r==null?void 0:r.error)==null?void 0:a.message)||((e=r==null?void 0:r.error)==null?void 0:e.data)||(r==null?void 0:r.error)||t.reason;if(l!=null&&l.includes("FailedOp")){let g="";const h=l.match(/FailedOp\((.*)\)/);if(h){const y=h[1].split(",");g=`(paymaster address: ${y[1]})`,l=y[2]}s=`The bundler has failed to include UserOperation in a batch: ${l} ${g}`}else s=`RPC error: ${l}
Status: ${i}
Code: ${d}`}const n=new Error(s);return n.stack=t.stack,n}catch{}return t}async verifyAllNecessaryFields(t){if(!t.to)throw new Error("Missing call target");if(!t.data&&!t.value)throw new Error("Missing call data or value")}connect(t){throw new Error("changing providers is not supported")}async getAddress(){return this.address||(this.address=await this.erc4337provider.getSenderAccountAddress()),this.address}async signMessage(t){await this.smartAccountAPI.checkAccountPhantom()&&(console.log("Account contract not deployed yet. Deploying account before signing message"),await(await this.sendTransaction({to:await this.getAddress(),data:"0x"})).wait());const[e,s]=await Promise.all([this.getChainId(),this.getAddress()]),n=q(t);let r,i;try{const l=new E(X(e,this.config.clientId),e);await new Z(s,["function getMessageHash(bytes32 _hash) public view returns (bytes32)"],l).getMessageHash(n),r=!0}catch{r=!1}if(r?i=(await Q(this,{name:"Account",version:"1",chainId:e,verifyingContract:s},{AccountMessage:[{name:"message",type:"bytes"}]},{message:P.encode(["bytes32"],[n])})).signature:i=await this.originalSigner.signMessage(t),await tt(t,i,s,e))return i;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")}async signTransaction(t,a){var d;const e=await f(t);await this.verifyAllNecessaryFields(e);const s=b(),n=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:e.to||"",data:((d=e.data)==null?void 0:d.toString())||"0x",value:e.value,gasLimit:e.gasLimit,nonce:s},a),r=await this.smartAccountAPI.signUserOp(n);return JSON.stringify(await v(r))}}class dt extends W{constructor(t,a,e,s,n,r,i){super({name:"ERC-4337 Custom Network",chainId:t}),this.chainId=t,this.config=a,this.originalSigner=e,this.originalProvider=s,this.httpRpcClient=n,this.entryPoint=r,this.smartAccountAPI=i,this.signer=new ct(a,e,this,n,i)}getSigner(){return this.signer}async perform(t,a){if(t==="sendTransaction"||t==="getTransactionReceipt")throw new Error("Should not get here. Investigate.");return t==="estimateGas"?c.from(5e5):await this.originalProvider.perform(t,a)}async getTransaction(t){return await super.getTransaction(t)}async getTransactionReceipt(t){const a=await t,e=await this.getSenderAccountAddress();return await new Promise((s,n)=>{new x(s,n,this.entryPoint,e,a).start()})}async getSenderAccountAddress(){return await this.smartAccountAPI.getAccountAddress()}async waitForTransaction(t,a,e){const s=await this.getSenderAccountAddress();return await new Promise((n,r)=>{new x(n,r,this.entryPoint,s,t,void 0,e).start()})}async constructUserOpTransactionResponse(t){const a=await f(t),e=await this.smartAccountAPI.getUserOpHash(a),s=async()=>await new Promise((n,r)=>{new x(n,r,this.entryPoint,a.sender,e,a.nonce).start()});return{hash:e,confirmations:0,from:a.sender,nonce:0,gasLimit:c.from(a.callGasLimit),value:c.from(0),data:D(a.callData),chainId:this.chainId,wait:async n=>{const r=await s();return a.initCode.length!==0&&await this.smartAccountAPI.checkAccountPhantom(),r}}}async detectNetwork(){return this.originalProvider.detectNetwork()}}function ht(o,t,a,e){const s=U.EntryPoint__factory.connect(o.entryPointAddress,a),n=new nt(o.bundlerUrl,o.entryPointAddress,e,o.clientId,o.secretKey);return new dt(e,o,o.localSigner,a,n,s,t)}const lt="0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";class ut{constructor(t){L(this,"isPhantom",!0),this.provider=t.provider,this.entryPointAddress=t.entryPointAddress,this.accountAddress=t.accountAddress,this.paymasterAPI=t.paymasterAPI,this.gasless=t.gasless,this.entryPointView=U.EntryPoint__factory.connect(t.entryPointAddress,t.provider).connect(C)}async checkAccountPhantom(){return this.isPhantom?((await this.provider.getCode(this.getAccountAddress())).length>2&&(this.isPhantom=!1),this.isPhantom):this.isPhantom}async getInitCode(){return await this.checkAccountPhantom()?await this.getAccountInitCode():"0x"}async getVerificationGasLimit(){return 1e5}async getUserOpHash(t){const a=await this.provider.getNetwork().then(e=>e.chainId);return at(t,this.entryPointAddress,a)}async getAccountAddress(){return this.senderAddress||(this.accountAddress?this.senderAddress=this.accountAddress:this.senderAddress=await this.getCounterFactualAddress()),this.senderAddress}async estimateCreationGas(t){if(!t||t==="0x")return 0;const a=t.substring(0,42),e="0x"+t.substring(42);return await this.provider.estimateGas({to:a,data:e})}async createUnsignedUserOp(t,a,e){const s=await this.getInitCode(),n=gt(a.value)??c.from(0),r=e!=null&&e.batchData?a.data:await this.prepareExecute(a.target,n,a.data).then(u=>u.encode());let{maxFeePerGas:i,maxPriorityFeePerGas:d}=a;if(!i||!d){const u=await $(this.provider);if(d||(d=u.maxPriorityFeePerGas??void 0),!i){i=u.maxFeePerGas??void 0;const w=(await this.provider.getNetwork()).chainId;(w===M.chainId||w===z.chainId||w===j.chainId)&&(d=i)}}if(!i||!d)throw new Error("maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely");const[l,g]=await Promise.all([this.getAccountAddress(),a.nonce?Promise.resolve(a.nonce):this.getNonce()]),h={sender:l,nonce:g,initCode:s,callData:r,maxFeePerGas:i,maxPriorityFeePerGas:d,callGasLimit:c.from(1e6),verificationGasLimit:c.from(1e6),preVerificationGas:c.from(1e6),paymasterAndData:"0x",signature:lt};if((e==null?void 0:e.gasless)!==void 0?e.gasless:this.gasless){const u=await this.paymasterAPI.getPaymasterAndData(h),p=u.paymasterAndData;if(p&&p!=="0x"&&(h.paymasterAndData=p),u.callGasLimit&&u.verificationGasLimit&&u.preVerificationGas)h.callGasLimit=c.from(u.callGasLimit),h.verificationGasLimit=c.from(u.verificationGasLimit),h.preVerificationGas=c.from(u.preVerificationGas);else{let w;try{w=await t.estimateUserOpGas(h)}catch(m){throw this.unwrapBundlerError(m)}if(h.callGasLimit=c.from(w.callGasLimit),h.verificationGasLimit=c.from(w.verificationGasLimit),h.preVerificationGas=c.from(w.preVerificationGas),p&&p!=="0x"){const m=await this.paymasterAPI.getPaymasterAndData(h);m.paymasterAndData&&m.paymasterAndData!=="0x"&&(h.paymasterAndData=m.paymasterAndData)}}}else{let u;try{u=await t.estimateUserOpGas(h)}catch(p){throw this.unwrapBundlerError(p)}h.callGasLimit=c.from(u.callGasLimit),h.verificationGasLimit=c.from(u.verificationGasLimit),h.preVerificationGas=c.from(u.preVerificationGas)}return{...h,signature:""}}async signUserOp(t){const a=await this.getUserOpHash(t),e=await this.signUserOpHash(a);return{...t,signature:e}}async getUserOpReceipt(t){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:3e4,e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:2e3;const s=Date.now()+a;for(;Date.now()<s;){const n=await this.entryPointView.queryFilter(this.entryPointView.filters.UserOperationEvent(t));if(n[0])return n[0].transactionHash;await new Promise(r=>setTimeout(r,e))}return null}unwrapBundlerError(t){var e;const a=((e=t==null?void 0:t.error)==null?void 0:e.message)||t.error||t.message||t;return new Error(a)}}function gt(o){return!o||o===""?null:c.from(o.toString())}class pt extends ut{constructor(t,a){super({...t,provider:a}),this.params=t,this.sdk=I.fromPrivateKey(H,t.chain,{clientId:t.clientId,secretKey:t.secretKey,supportedChains:typeof t.chain=="object"?[t.chain]:void 0})}async getChainId(){return await this.provider.getNetwork().then(t=>t.chainId)}async getAccountContract(){var t;return this.accountContract||((t=this.params.accountInfo)!=null&&t.abi?this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),this.params.accountInfo.abi):this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),B)),this.accountContract}async getAccountInitCode(){const t=await this.getFactoryContract();console.log("Deploying smart wallet via factory");const a=await this.params.localSigner.getAddress(),e=await this.params.factoryInfo.createAccount(t,a);try{console.log("Cost to deploy smart wallet: ",(await e.estimateGasCost()).ether,"ETH")}catch(s){console.error("Cost to deploy smart wallet: unknown",s)}return K([t.getAddress(),e.encode()])}async getFactoryContract(){var t;return this.factoryContract?this.factoryContract:((t=this.params.factoryInfo)!=null&&t.abi?this.factoryContract=await this.sdk.getContract(this.params.factoryAddress,this.params.factoryInfo.abi):this.factoryContract=await this.sdk.getContract(this.params.factoryAddress),this.factoryContract)}async getCounterFactualAddress(){if(this.params.accountAddress)return this.params.accountAddress;const t=await this.getFactoryContract(),a=await this.params.localSigner.getAddress();return this.params.factoryInfo.getAccountAddress(t,a)}async getNonce(){if(await this.checkAccountPhantom())return c.from(0);const t=await this.getAccountContract();return this.params.accountInfo.getNonce(t)}async prepareExecute(t,a,e){const s=await this.getAccountContract();return this.params.accountInfo.execute(s,t,a,e)}async prepareExecuteBatch(t,a,e){return(await this.getAccountContract()).prepare("executeBatch",[t,a,e])}async signUserOpHash(t){return await this.params.localSigner.signMessage(V(t))}async isAcountDeployed(){return!await this.checkAccountPhantom()}}class yt extends S{constructor(t){super(),this.config=t}async initialize(t){const a=this.config,e=_(a.chain,{clientId:a.clientId,secretKey:a.secretKey});this.chainId=(await e.getNetwork()).chainId;const s=this.config.bundlerUrl||`https://${this.chainId}.bundler.thirdweb.com`,n=this.config.paymasterUrl||`https://${this.chainId}.bundler.thirdweb.com/v2`,r=a.entryPointAddress||F,i=await t.personalWallet.getSigner(),d={chain:a.chain,localSigner:i,entryPointAddress:r,bundlerUrl:s,paymasterAPI:this.config.paymasterAPI?this.config.paymasterAPI:ot(n,r,this.config.clientId,this.config.secretKey),gasless:a.gasless,factoryAddress:a.factoryAddress,accountAddress:t.accountAddress,factoryInfo:a.factoryInfo||this.defaultFactoryInfo(),accountInfo:a.accountInfo||this.defaultAccountInfo(),clientId:a.clientId,secretKey:a.secretKey};this.personalWallet=t.personalWallet;const l=new pt(d,e);this.aaProvider=ht(d,l,e,this.chainId),this.accountApi=l}async connect(t){return await this.initialize(t),await this.getAddress()}getProvider(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider)}async getSigner(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider.getSigner())}async getAddress(){return(await this.getSigner()).getAddress()}async isConnected(){try{return!!await this.getAddress()}catch{return!1}}async disconnect(){this.personalWallet=void 0,this.aaProvider=void 0}async switchChain(t){if((await(await this.getProvider()).getNetwork()).chainId!==t)throw new Error("Not supported.")}setupListeners(){return Promise.resolve()}updateChains(t){}async hasPermissionToExecute(t){var r;const a=await this.getAccountContract(),s=await(await this.getSigner()).getAddress(),n=(r=(await a.account.getAllSigners()).filter(i=>T(i.signer)===T(s))[0])==null?void 0:r.permissions;return n?n.approvedCallTargets.includes(t.getTarget()):!1}async send(t,a){return(await this.getSigner()).sendTransaction({to:t.getTarget(),data:t.encode(),value:await t.getValue()},a)}async execute(t,a){return{receipt:await(await this.send(t,a)).wait()}}async sendBatch(t,a){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await this.getSigner(),{tx:s,batchData:n}=await this.prepareBatchTx(t);return await e.sendTransaction({to:await e.getAddress(),data:s.encode(),value:0},{...a,batchData:n})}async executeBatch(t,a){return{receipt:await(await this.sendBatch(t,a)).wait()}}async sendRaw(t,a){if(!this.accountApi)throw new Error("Personal wallet not connected");return(await this.getSigner()).sendTransaction(t,a)}async executeRaw(t,a){return{receipt:await(await this.sendRaw(t,a)).wait()}}async sendBatchRaw(t,a){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await this.getSigner(),s=await this.prepareBatchRaw(t);return e.sendTransaction({to:await e.getAddress(),data:s.tx.encode(),value:0},{...a,batchData:s.batchData})}async executeBatchRaw(t,a){return{receipt:await(await this.sendBatchRaw(t,a)).wait()}}async estimate(t,a){if(!this.accountApi)throw new Error("Personal wallet not connected");return this.estimateTx({target:t.getTarget(),data:t.encode(),value:await t.getValue(),gasLimit:await t.getOverrides().gasLimit,maxFeePerGas:await t.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await t.getOverrides().maxPriorityFeePerGas,nonce:await t.getOverrides().nonce},a)}async estimateRaw(t,a){var s;if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await f(t);return this.estimateTx({target:e.to||C,data:((s=e.data)==null?void 0:s.toString())||"",value:e.value||c.from(0),gasLimit:e.gasLimit,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce},a)}async estimateBatch(t,a){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:e,batchData:s}=await this.prepareBatchTx(t);return this.estimateTx({target:e.getTarget(),data:e.encode(),value:await e.getValue(),gasLimit:await e.getOverrides().gasLimit,maxFeePerGas:await e.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await e.getOverrides().maxPriorityFeePerGas,nonce:await e.getOverrides().nonce},{...a,batchData:s})}async estimateBatchRaw(t,a){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:e,batchData:s}=await this.prepareBatchRaw(t);return this.estimateTx({target:e.getTarget(),data:e.encode(),value:await e.getValue(),gasLimit:await e.getOverrides().gasLimit,maxFeePerGas:await e.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await e.getOverrides().maxPriorityFeePerGas,nonce:await e.getOverrides().nonce},{...a,batchData:s})}async deploy(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await this.getSigner();return{receipt:await(await a.sendTransaction({to:await a.getAddress(),data:"0x"},{...t,batchData:{targets:[],data:[],values:[]}})).wait()}}async isDeployed(){if(!this.accountApi)throw new Error("Personal wallet not connected");return await this.accountApi.isAcountDeployed()}async deployIfNeeded(t){await this.isDeployed()||await this.deploy(t)}async grantPermissions(t,a){return await this.deployIfNeeded(),(await this.getAccountContract()).account.grantPermissions(t,a)}async revokePermissions(t){return await this.deployIfNeeded(),(await this.getAccountContract()).account.revokeAccess(t)}async addAdmin(t){return await this.deployIfNeeded(),(await this.getAccountContract()).account.grantAdminPermissions(t)}async removeAdmin(t){return await this.deployIfNeeded(),(await this.getAccountContract()).account.revokeAdminPermissions(t)}async getAllActiveSigners(){var a;if(await this.isDeployed())return(await this.getAccountContract()).account.getAllAdminsAndSigners();{const e=await((a=this.personalWallet)==null?void 0:a.getSigner());if(!e)throw new Error("Personal wallet not connected");return[{isAdmin:!0,signer:await e.getAddress(),permissions:{startDate:new Date(0),expirationDate:new Date(0),nativeTokenLimitPerTransaction:c.from(0),approvedCallTargets:[]}}]}}async getAccountContract(){var e;if(!await this.isDeployed())throw new Error("Account contract is not deployed yet. You can deploy it manually using SmartWallet.deploy(), or by executing a transaction from this wallet.");const a=I.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return(e=this.config.accountInfo)!=null&&e.abi?a.getContract(await this.getAddress(),this.config.accountInfo.abi):a.getContract(await this.getAddress())}async getFactoryContract(){var a;const t=I.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return(a=this.config.factoryInfo)!=null&&a.abi?t.getContract(this.config.factoryAddress,this.config.factoryInfo.abi):t.getContract(this.config.factoryAddress)}defaultFactoryInfo(){return{createAccount:async(t,a)=>t.prepare("createAccount",[a,O("")]),getAccountAddress:async(t,a)=>await t.call("getAddress",[a,O("")])}}defaultAccountInfo(){return{execute:async(t,a,e,s)=>t.prepare("execute",[a,e,s]),getNonce:async t=>t.call("getNonce",[])}}async estimateTx(t,a){if(!this.accountApi||!this.aaProvider)throw new Error("Personal wallet not connected");let e=c.from(0);const[s,n]=await Promise.all([this.getProvider(),this.isDeployed()]);n||(e=await this.estimateDeploymentGasLimit());const[r,i]=await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient,t,a),R(s)]),d=await f(r),l=c.from(d.callGasLimit),g=l.mul(i),h=e.mul(i),y=h.add(g);return{ether:k(y),wei:y,details:{deployGasLimit:e,transactionGasLimit:l,gasPrice:i,transactionCost:g,deployCost:h,totalCost:y}}}async estimateDeploymentGasLimit(){if(!this.accountApi)throw new Error("Personal wallet not connected");const t=await this.accountApi.getInitCode(),[a,e]=await Promise.all([this.accountApi.estimateCreationGas(t),this.accountApi.getVerificationGasLimit()]);return c.from(e).add(a)}async prepareBatchRaw(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await Promise.all(t.map(r=>f(r))),e=a.map(r=>r.to||C),s=a.map(r=>r.data||"0x"),n=a.map(r=>r.value||c.from(0));return{tx:await this.accountApi.prepareExecuteBatch(e,n,s),batchData:{targets:e,data:s,values:n}}}async prepareBatchTx(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=t.map(n=>n.getTarget()),e=t.map(n=>n.encode()),s=await Promise.all(t.map(n=>n.getValue()));return{tx:await this.accountApi.prepareExecuteBatch(a,s,e),batchData:{targets:a,data:e,values:s}}}}export{yt as SmartWalletConnector};
