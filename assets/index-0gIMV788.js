var O=Object.defineProperty;var A=(p,s,e)=>s in p?O(p,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):p[s]=e;var d=(p,s,e)=>(A(p,typeof s!="symbol"?s+"":s,e),e);import{bB as v,bC as F,bD as g}from"./index-4DoMYjDR.js";var E=function(s){for(var e=new Buffer(s.length),t=0,r=s.length-1;t<=r;++t,--r)e[t]=s[r],e[r]=s[t];return e};const P=v(E);var S={exports:{}};(function(p,s){(function(e,t){p.exports=t()})(F,function(){function e(f,a){var i=a?"└":"├";return f?i+="─ ":i+="──┐",i}function t(f,a){var i=[];for(var h in f)f.hasOwnProperty(h)&&(a&&typeof f[h]=="function"||i.push(h));return i}function r(f,a,i,h,o,l,u){var c="",m=0,w,H,y=h.slice(0);if(y.push([a,i])&&h.length>0&&(h.forEach(function(B,L){L>0&&(c+=(B[1]?" ":"│")+"  "),!H&&B[0]===a&&(H=!0)}),c+=e(f,i)+f,o&&(typeof a!="object"||a instanceof Date)&&(c+=": "+a),H&&(c+=" (circular ref.)"),u(c)),!H&&typeof a=="object"){var x=t(a,l);x.forEach(function(B){w=++m===x.length,r(B,a[B],w,y,o,l,u)})}}var n={};return n.asLines=function(f,a,i,h){var o=typeof i!="function"?i:!1;r(".",f,!1,[],a,o,h||i)},n.asTree=function(f,a,i){var h="";return r(".",f,!1,[],a,i,function(o){h+=o+`
`}),h},n})})(S);var D=S.exports;class b{print(){b.print(this)}bufferIndexOf(s,e){if(arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1)return this.binarySearch(s,e,g.Buffer.compare);const r=(n,f)=>n.equals(f);return this.linearSearch(s,e,r)}static binarySearch(s,e,t){let r=0,n=s.length-1;for(;r<=n;){const f=Math.floor((r+n)/2),a=t(s[f],e);if(a===0){for(let i=f-1;i>=0;i--)if(t(s[i],e)!==0)return i+1;return 0}else a<0?r=f+1:n=f-1}return-1}binarySearch(s,e,t){return b.binarySearch(s,e,t)}static linearSearch(s,e,t){for(let r=0;r<s.length;r++)if(t(s[r],e))return r;return-1}linearSearch(s,e,t){return b.linearSearch(s,e,t)}static bufferify(s){if(!g.Buffer.isBuffer(s)){if(typeof s=="object"&&s.words)return g.Buffer.from(s.toString(N),"hex");if(b.isHexString(s))return g.Buffer.from(s.replace(/^0x/,""),"hex");if(typeof s=="string")return g.Buffer.from(s);if(typeof s=="bigint")return g.Buffer.from(s.toString(16),"hex");if(s instanceof Uint8Array)return g.Buffer.from(s.buffer);if(typeof s=="number"){let e=s.toString();return e.length%2&&(e=`0${e}`),g.Buffer.from(e,"hex")}else if(ArrayBuffer.isView(s))return g.Buffer.from(s.buffer,s.byteOffset,s.byteLength)}return s}bigNumberify(s){return b.bigNumberify(s)}static bigNumberify(s){if(typeof s=="bigint")return s;if(typeof s=="string")return s.startsWith("0x")&&b.isHexString(s)?BigInt("0x"+s.replace("0x","").toString()):BigInt(s);if(g.Buffer.isBuffer(s))return BigInt("0x"+s.toString("hex"));if(s instanceof Uint8Array)return q(s);if(typeof s=="number")return BigInt(s);throw new Error("cannot bigNumberify")}static isHexString(s){return typeof s=="string"&&/^(0x)?[0-9A-Fa-f]*$/.test(s)}static print(s){console.log(s.toString())}bufferToHex(s){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return b.bufferToHex(s,e)}static bufferToHex(s){return`${(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0)?"0x":""}${(s||g.Buffer.alloc(0)).toString("hex")}`}bufferify(s){return b.bufferify(s)}bufferifyFn(s){return e=>{const t=s(e);if(g.Buffer.isBuffer(t))return t;if(this.isHexString(t))return g.Buffer.from(t.replace("0x",""),"hex");if(typeof t=="string")return g.Buffer.from(t);if(typeof t=="bigint")return g.Buffer.from(e.toString(16),"hex");if(ArrayBuffer.isView(t))return g.Buffer.from(t.buffer,t.byteOffset,t.byteLength);const r=U(e.toString("hex")),n=s(r),f=j(n);return g.Buffer.from(f,"hex")}}isHexString(s){return b.isHexString(s)}log2(s){return s===1?0:1+this.log2(s/2|0)}zip(s,e){return s.map((t,r)=>[t,e[r]])}static hexZeroPad(s,e){return"0x"+s.replace("0x","").padStart(e,"0")}}var M=b;function N(p){const s=p.words,e=new ArrayBuffer(s.length*4),t=new Uint8Array(e);for(let r=0;r<s.length;r++)t[r*4]=s[r]>>24&255,t[r*4+1]=s[r]>>16&255,t[r*4+2]=s[r]>>8&255,t[r*4+3]=s[r]&255;return e}function U(p){const s=new Uint8Array(p.length/2);for(let e=0;e<p.length;e+=2)s[e/2]=parseInt(p.substring(e,e+2),16);return s.buffer}function j(p){const s=new Uint8Array(p);return Array.from(s).map(e=>e.toString(16).padStart(2,"0")).join("")}function q(p){const s=Array.from(p).map(e=>e.toString(16).padStart(2,"0")).join("");return BigInt(`0x${s}`)}class T extends M{constructor(e,t){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};super();d(this,"duplicateOdd",!1);d(this,"concatenator",g.Buffer.concat);d(this,"hashLeaves",!1);d(this,"isBitcoinTree",!1);d(this,"leaves",[]);d(this,"layers",[]);d(this,"sortLeaves",!1);d(this,"sortPairs",!1);d(this,"sort",!1);d(this,"fillDefaultHash",null);d(this,"complete",!1);if(r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if(typeof r.fillDefaultHash=="function")this.fillDefaultHash=r.fillDefaultHash;else if(g.Buffer.isBuffer(r.fillDefaultHash)||typeof r.fillDefaultHash=="string")this.fillDefaultHash=(n,f)=>r.fillDefaultHash;else throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){var e;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:((e=this.fillDefaultHash)==null?void 0:e.toString())??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(g.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&t===1&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let n=0;n<e.length;n+=2){if(n>=r){this.layers[t].push(...e.slice(r));break}else if(n+1===e.length&&e.length%2===1){const o=e[e.length-1];let l=o;if(this.isBitcoinTree){l=this.hashFn(this.concatenator([P(o),P(o)])),l=P(this.hashFn(l)),this.layers[t].push(l);continue}else if(!this.duplicateOdd){this.layers[t].push(e[n]);continue}}const f=e[n],a=n+1===e.length?f:e[n+1];let i=null;this.isBitcoinTree?i=[P(f),P(a)]:i=[f,a],this.sortPairs&&i.sort(g.Buffer.compare);let h=this.hashFn(this.concatenator(i));this.isBitcoinTree&&(h=P(this.hashFn(h))),this.layers[t].push(h)}e=this.layers[t]}}addLeaf(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(g.Buffer.compare))),this.leaves.filter(t=>this.bufferIndexOf(e,t,this.sortLeaves)!==-1)):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?g.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++)if(t[r].equals(e))return r;return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(t=>T.bufferToHex(t)),null,2)}static unmarshalLeaves(e){let t=null;if(typeof e=="string")t=JSON.parse(e);else if(e instanceof Object)t=e;else throw new Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(T.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(r=>this.bufferToHex(r))):e.push(t),e),[])}getLayersFlat(){const e=this.layers.reduce((t,r)=>(Array.isArray(r)?t.unshift(...r):t.unshift(r),t),[]);return e.unshift(g.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return this.layers.length===0?g.Buffer.from([]):this.layers[this.layers.length-1][0]||g.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(typeof e>"u")throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let n=0;n<this.leaves.length;n++)g.Buffer.compare(e,this.leaves[n])===0&&(t=n)}if(t<=-1)return[];for(let n=0;n<this.layers.length;n++){const f=this.layers[n],a=t%2,i=a?t-1:this.isBitcoinTree&&t===f.length-1&&n<this.layers.length-1?t:t+1;i<f.length&&r.push({position:a?"left":"right",data:f[i]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(r=>this.bufferToHex(r.data))}getProofs(){const e=[],t=[];return this.getProofsDFS(this.layers.length-1,0,e,t),t}getProofsDFS(e,t,r,n){const f=t%2;if(e===-1){f||n.push([...r].reverse());return}if(t>=this.layers[e].length)return;const a=this.layers[e],i=f?t-1:t+1;let h=!1;i<a.length&&(h=!0,r.push({position:f?"left":"right",data:a[i]}));const o=t*2,l=t*2+1;this.getProofsDFS(e-1,o,r,n),this.getProofsDFS(e-1,l,r,n),h&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(r=>[r.position==="left"?0:1,this.bufferToHex(r.data)])}getProofIndices(e,t){const r=2**t;let n=new Set;for(const o of e){let l=r+o;for(;l>1;)n.add(l^1),l=l/2|0}const f=e.map(o=>r+o),a=Array.from(n).sort((o,l)=>o-l).reverse();n=f.concat(a);const i=new Set,h=[];for(let o of n)if(!i.has(o))for(h.push(o);o>1&&(i.add(o),!!i.has(o^1));)o=o/2|0;return h.filter(o=>!e.includes(o-r))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),n=[];for(let i=0;i<r;i++)t%2!==0&&n.push({index:i,leavesCount:t}),t=Math.ceil(t/2);const f=[];let a=e;for(let i=0;i<r;i++){let o=a.map(u=>u%2===0?u+1:u-1).filter(u=>!a.includes(u));const l=n.find(u=>{let{index:c}=u;return c===i});l&&a.includes(l.leavesCount-1)&&(o=o.slice(0,-1)),f.push(o),a=[...new Set(a.map(u=>u%2===0?u/2:u%2===0?(u+1)/2:(u-1)/2))]}return f}getMultiProof(e,t){if(this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat()),this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let n=t;this.sortPairs&&(n=n.sort(g.Buffer.compare));let f=n.map(o=>this.bufferIndexOf(this.leaves,o,this.sortLeaves)).sort((o,l)=>o===l?0:o>l?1:-1);if(!f.every(o=>o!==-1))throw new Error("Element does not exist in Merkle tree");const a=[],i=[];let h=[];for(let o=0;o<this.layers.length;o++){const l=this.layers[o];for(let u=0;u<f.length;u++){const c=f[u],m=this.getPairNode(l,c);a.push(l[c]),m&&i.push(m),h.push(c/2|0)}f=h.filter((u,c,m)=>m.indexOf(u)===c),h=[]}return i.filter(o=>!a.includes(o))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(n=>e[n])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],n=t;for(const f of e){const a=[];for(const h of n){if(h%2===0){const l=h+1;if(!n.includes(l)&&f[l]){a.push(f[l]);continue}}const o=h-1;if(!n.includes(o)&&f[o]){a.push(f[o]);continue}}r=r.concat(a);const i=new Set;for(const h of n){if(h%2===0){i.add(h/2);continue}if(h%2===0){i.add((h+1)/2);continue}i.add((h-1)/2)}n=Array.from(i)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(r=>this.bufferToHex(r))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(e.every(Number.isInteger)?r=[...e].sort((i,h)=>i===h?0:i>h?1:-1):r=e.map(i=>this.bufferIndexOf(this.leaves,i,this.sortLeaves)).sort((i,h)=>i===h?0:i>h?1:-1),!r.every(i=>i!==-1))throw new Error("Element does not exist in Merkle tree");const n=t.map(i=>this.bufferify(i)),f=[],a=[];for(let i=0;i<this.layers.length;i++){const h=this.layers[i];r=r.reduce((o,l)=>{if(!f.includes(h[l])){const c=this.getPairNode(h,l),m=n.includes(h[l])||n.includes(c);c&&a.push(!m),f.push(h[l]),f.push(c)}return o.push(l/2|0),o},[])}return a}verify(e,t,r){let n=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let f=0;f<e.length;f++){const a=e[f];let i=null,h=null;if(typeof a=="string")i=this.bufferify(a),h=!0;else if(Array.isArray(a))h=a[0]===0,i=this.bufferify(a[1]);else if(g.Buffer.isBuffer(a))i=a,h=!0;else if(a instanceof Object)i=this.bufferify(a.data),h=a.position==="left";else throw new Error("Expected node to be of type string or object");const o=[];this.isBitcoinTree?(o.push(P(n)),o[h?"unshift":"push"](P(i)),n=this.hashFn(this.concatenator(o)),n=P(this.hashFn(n))):this.sortPairs?g.Buffer.compare(n,i)===-1?(o.push(n,i),n=this.hashFn(this.concatenator(o))):(o.push(i,n),n=this.hashFn(this.concatenator(o))):(o.push(n),o[h?"unshift":"push"](i),n=this.hashFn(this.concatenator(o)))}return g.Buffer.compare(n,r)===0}verifyMultiProof(e,t,r,n,f){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,n,f);const i=Math.ceil(Math.log2(n));e=this.bufferify(e),r=r.map(u=>this.bufferify(u)),f=f.map(u=>this.bufferify(u));const h={};for(const[u,c]of this.zip(t,r))h[2**i+u]=c;for(const[u,c]of this.zip(this.getProofIndices(t,i),f))h[u]=c;let o=Object.keys(h).map(u=>Number(u)).sort((u,c)=>u-c);o=o.slice(0,o.length-1);let l=0;for(;l<o.length;){const u=o[l];if(u>=2&&{}.hasOwnProperty.call(h,u^1)){let c=[h[u-u%2],h[u-u%2+1]];this.sortPairs&&(c=c.sort(g.Buffer.compare));const m=c[1]?this.hashFn(this.concatenator(c)):c[0];h[u/2|0]=m,o.push(u/2|0)}l+=1}return!t.length||{}.hasOwnProperty.call(h,1)&&h[1].equals(e)}verifyMultiProofWithFlags(e,t,r,n){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const f=t.length,a=n.length,i=[];let h=0,o=0,l=0;for(let u=0;u<a;u++){const c=n[u]?h<f?t[h++]:i[o++]:r[l++],m=h<f?t[h++]:i[o++],w=[c,m].sort(g.Buffer.compare);i[u]=this.hashFn(this.concatenator(w))}return g.Buffer.compare(i[a-1],e)===0}verifyMultiProofForUnevenTree(e,t,r,n,f){e=this.bufferify(e),r=r.map(i=>this.bufferify(i)),f=f.map(i=>this.bufferify(i));const a=this.calculateRootForUnevenTree(t,r,n,f);return e.equals(a)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map(r=>r.map(n=>this.bufferToHex(n,!1))),t=[];for(let r=0;r<e.length;r++){const n=[];for(let f=0;f<e[r].length;f++){const a={[e[r][f]]:null};if(t.length){a[e[r][f]]={};const i=t.shift(),h=Object.keys(i)[0];if(a[e[r][f]][h]=i[h],t.length){const o=t.shift(),l=Object.keys(o)[0];a[e[r][f]][l]=o[l]}}n.push(a)}t.push(...n)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return D.asTree(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=(e==null?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,n){const f=this.zip(e,t).sort((u,c)=>{let[m]=u,[w]=c;return m-w}),a=f.map(u=>{let[c]=u;return c}),i=this.getProofIndicesForUnevenTree(a,r);let h=0;const o=[];for(let u=0;u<i.length;u++){const c=i[u],m=h;h+=c.length,o[u]=this.zip(c,n.slice(m,h))}const l=[f];for(let u=0;u<o.length;u++){const c=o[u].concat(l[u]).sort((y,x)=>{let[B]=y,[L]=x;return B-L}).map(y=>{let[,x]=y;return x}),m=l[u].map(y=>{let[x]=y;return x}),w=[...new Set(m.map(y=>y%2===0?y/2:y%2===0?(y+1)/2:(y-1)/2))],H=[];for(let y=0;y<w.length;y++){const x=w[y],B=c[y*2],L=c[y*2+1],I=L?this.hashFn(this.concatenator([B,L])):B;H.push([x,I])}l.push(H)}return l[l.length-1][0][1]}}var R=function p(s,e){if(s===e)return!0;if(s&&e&&typeof s=="object"&&typeof e=="object"){if(s.constructor!==e.constructor)return!1;var t,r,n;if(Array.isArray(s)){if(t=s.length,t!=e.length)return!1;for(r=t;r--!==0;)if(!p(s[r],e[r]))return!1;return!0}if(s.constructor===RegExp)return s.source===e.source&&s.flags===e.flags;if(s.valueOf!==Object.prototype.valueOf)return s.valueOf()===e.valueOf();if(s.toString!==Object.prototype.toString)return s.toString()===e.toString();if(n=Object.keys(s),t=n.length,t!==Object.keys(e).length)return!1;for(r=t;r--!==0;)if(!Object.prototype.hasOwnProperty.call(e,n[r]))return!1;for(r=t;r--!==0;){var f=n[r];if(!p(s[f],e[f]))return!1}return!0}return s!==s&&e!==e};const z=v(R);export{T as M,z as d};
