import{aD as x,aW as R,bn as _,aH as W,aG as b,aw as G,aF as ae,B as C,b0 as ne,ap as v,a2 as D,bj as h,bm as q,as as J,aX as re,bo as B,bp as se,e as ie,a4 as oe,a1 as p,ax as L,bq as N,br as ce,bs as j,bt as le,bu as $,t as ue,a3 as Q,bv as de,bi as me,bw as pe}from"./index-4DoMYjDR.js";import{M as O}from"./index-0gIMV788.js";import{S as Y,E as ye}from"./assertEnabled-9932cdf6.browser.esm-2yA8JHoA.js";import{N as E}from"./setErc20Allowance-001b07da.browser.esm-x-dAPP5B.js";function ve(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function Ue(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function P(e,t){return e==="unlimited"?x:R(e,t)}async function Z(e){const a=Array.from({length:Math.ceil(e.length/25e3)},(s,o)=>e.slice(o*25e3,o*25e3+25e3)),r=[],n=await Promise.all(a.map(s=>j.parseAsync(s)));for(const s of n)r.push(...s);return r}const he=2;let U=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class f{constructor(t,a,r,n,s){this.storage=t,this.shardNybbles=n,this.baseUri=a,this.originalEntriesUri=r,this.tokenDecimals=s,this.shards={},this.trees={}}static async fromUri(t,a){try{const r=await a.downloadJSON(t);if(r.isShardedMerkleTree)return f.fromShardedMerkleTreeInfo(r,a)}catch{return}}static async fromShardedMerkleTreeInfo(t,a){return new f(a,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,a,r,n){switch(n){case U.V1:return J(["address","uint256"],[t.address,P(t.maxClaimable,a)]);case U.V2:return J(["address","uint256","uint256","address"],[t.address,P(t.maxClaimable,a),P(t.price||"unlimited",r),t.currencyAddress||b])}}static async fetchAndCacheDecimals(t,a,r){if(!r)return 18;let n=t[r];return n===void 0&&(n=(await re(a,r)).decimals,t[r]=n),n}static async buildAndUpload(t,a,r,n,s){let o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:he;const i=await Z(t),c={};for(const T of i){const g=T.address.slice(2,2+o).toLowerCase();c[g]===void 0&&(c[g]=[]),c[g].push(T)}const u={},d=await Promise.all(Object.entries(c).map(async T=>{let[g,M]=T;return[g,new O(await Promise.all(M.map(async A=>{const te=await f.fetchAndCacheDecimals(u,r,A.currencyAddress);return f.hashEntry(A,a,te,s)})),B,{sort:!0}).getHexRoot()]})),l=Object.fromEntries(d),y=new O(Object.values(l),B,{sort:!0}),S=[];for(const[T,g]of Object.entries(c)){const M={proofs:y.getProof(l[T]).map(A=>"0x"+A.data.toString("hex")),entries:g};S.push({data:JSON.stringify(M),name:`${T}.json`})}const w=await n.uploadBatch(S),k=w[0].slice(0,w[0].lastIndexOf("/")),m=await n.upload(i),V={merkleRoot:y.getHexRoot(),baseUri:k,originalEntriesUri:m,shardNybbles:o,tokenDecimals:a,isShardedMerkleTree:!0},ee=await n.upload(V);return{shardedMerkleInfo:V,uri:ee}}async getProof(t,a,r){const n=t.slice(2,2+this.shardNybbles).toLowerCase();let s=this.shards[n];const o={};if(s===void 0)try{const l=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;s=this.shards[n]=await this.storage.downloadJSON(`${l}${n}.json`);const y=await Promise.all(s.entries.map(async S=>{const w=await f.fetchAndCacheDecimals(o,a,S.currencyAddress);return f.hashEntry(S,this.tokenDecimals,w,r)}));this.trees[n]=new O(y,B,{sort:!0})}catch{return null}const i=s.entries.find(l=>l.address.toLowerCase()===t.toLowerCase());if(!i)return null;const c=await f.fetchAndCacheDecimals(o,a,i.currencyAddress),u=f.hashEntry(i,this.tokenDecimals,c,r),d=this.trees[n].getProof(u).map(l=>"0x"+l.data.toString("hex"));return se.parseAsync({...i,proof:d.concat(s.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function fe(e,t,a,r,n,s){if(!a)return null;const o=a[t];if(o){const i=await n.downloadJSON(o);if(i.isShardedMerkleTree&&i.merkleRoot===t)return await(await f.fromShardedMerkleTreeInfo(i,n)).getProof(e,r,s);const c=await _.parseAsync(i);if(t===c.merkleRoot)return c.claims.find(u=>u.address.toLowerCase()===e.toLowerCase())||null}return null}function We(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function De(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function Se(e,t,a,r,n){const s=e.getSigner(),o=e.getProvider(),i=(await ie(()=>import("./index-4DoMYjDR.js").then(S=>S.fq),__vite__mapDeps([0,1]))).default,c=new oe(s||o,t,i,e.options,e.storage),u=await e.getSignerAddress(),d=e.address,l=await c.read("allowance",[u,d]),y=C.from(a).mul(C.from(r)).div(R("1",n));l.lt(y)&&await c.sendTransaction("approve",[d,l.add(y)])}async function qe(e,t,a,r,n,s,o,i,c){let u=P(a.maxClaimablePerWallet,n),d=[W([0],32)],l=a.price,y=a.currencyAddress;try{if(!a.merkleRootHash.toString().startsWith(b)){const m=await fe(e,a.merkleRootHash.toString(),await r(),s.getProvider(),o,c);if(m)d=m.proof,u=m.maxClaimable==="unlimited"?x:R(m.maxClaimable,n),l=m.price===void 0||m.price==="unlimited"?x:await G(s.getProvider(),m.price,m.currencyAddress||b),y=m.currencyAddress||b;else if(c===U.V1)throw new Error("No claim found for this address")}}catch(m){if((m==null?void 0:m.message)==="No claim found for this address")throw m;console.warn("failed to check claim condition merkle root hash, continuing anyways",m)}const S=await s.getCallOverrides()||{},w=l.toString()!==x.toString()?l:a.price,k=y!==b?y:a.currencyAddress;return w.gt(0)&&(ae(k)?S.value=C.from(w).mul(t).div(R("1",n)):i&&await Se(s,k,w,t,n)),{overrides:S,proofs:d,maxClaimable:u,price:w,currencyAddress:k,priceInProof:l,currencyAddressInProof:y}}const we=p.object({name:p.string(),symbol:p.string(),decimals:p.number()}),be=we.extend({value:h,displayValue:p.string()}),Ce=p.object({name:p.string().optional()}).catchall(p.unknown()),H=p.object({startTime:Y,currencyAddress:p.string().default(L),price:D.default(0),maxClaimableSupply:N,maxClaimablePerWallet:N,waitInSeconds:q.default(0),merkleRootHash:ce.default(W([0],32)),snapshot:p.optional(j).nullable(),metadata:Ce.optional()}),Te=p.array(H),K=H.extend({availableSupply:N,currentMintSupply:N,currencyMetadata:be.default({value:C.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h,waitInSeconds:h,startTime:h.transform(e=>new Date(e.toNumber()*1e3)),snapshot:j.optional().nullable()});async function ge(e,t,a,r,n){const s=await Z(e),o=s.map(u=>u.address);if(new Set(o).size<o.length)throw new pe;const c=await f.buildAndUpload(s,t,a,r,n);return{merkleRoot:c.shardedMerkleInfo.merkleRoot,snapshotUri:c.uri}}function Pe(e,t){const a=C.from(e),r=C.from(t);return a.eq(r)?0:a.gt(r)?1:-1}async function ke(e,t,a,r,n){const s=[];return{inputsWithSnapshots:await Promise.all(e.map(async i=>{if(i.snapshot&&i.snapshot.length>0){const c=await ge(i.snapshot,t,a,r,n);s.push(c),i.merkleRootHash=c.merkleRoot}else i.merkleRootHash=W([0],32);return i})),snapshotInfos:s}}async function xe(e,t,a,r){const n=e.currencyAddress===b?L:e.currencyAddress,s=P(e.maxClaimableSupply,t),o=P(e.maxClaimablePerWallet,t);let i;return e.metadata&&(typeof e.metadata=="string"?i=e.metadata:i=await r.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await G(a,e.price,n),currency:n,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:i}}async function Le(e,t,a,r,n){const{inputsWithSnapshots:s,snapshotInfos:o}=await ke(e,t,a,r,n),i=await Te.parseAsync(s),c=(await Promise.all(i.map(u=>xe(u,t,a,r)))).sort((u,d)=>Pe(u.startTimestamp,d.startTimestamp));return{snapshotInfos:o,sortedConditions:c}}async function Ae(e,t,a){if(!t)return null;const r=t[e];if(r){const n=await a.downloadJSON(r);if(n.isShardedMerkleTree&&n.merkleRoot===e){const s=await f.fromUri(r,a);return(s==null?void 0:s.getAllEntries())||null}else{const s=await _.parseAsync(n);if(e===s.merkleRoot)return s.claims.map(o=>({address:o.address,maxClaimable:o.maxClaimable,price:o.price,currencyAddress:o.currencyAddress}))}}return null}function I(e,t){return e.toString()===x.toString()?"unlimited":v(e,t)}async function je(e,t,a,r,n,s){var y;const o=await ne(a,e.currency,e.pricePerToken),i=I(e.maxClaimableSupply,t),c=I(e.maxClaimablePerWallet,t),u=I(C.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),d=I(e.supplyClaimed,t);let l;return e.metadata&&(l=await n.downloadJSON(e.metadata)),K.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:i,maxClaimablePerWallet:c,currentMintSupply:d,availableSupply:u,waitInSeconds:(y=e.waitTimeInSecondsBetweenClaims)==null?void 0:y.toString(),price:C.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:o,merkleRootHash:e.merkleRoot,snapshot:s?await Ae(e.merkleRoot,r,n):void 0,metadata:l})}async function He(e,t,a){if(e>=a.length)throw Error(`Index out of bounds - got index: ${e} with ${a.length} conditions`);const r=a[e].currencyMetadata.decimals,n=a[e].price,s=v(n,r),o=await H.parseAsync({...a[e],price:s,...t}),i=await K.parseAsync({...o,price:n});return a.map((c,u)=>{let d;u===e?d=i:d=c;const l=v(d.price,r);return{...d,price:l}})}let ze=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function Ie(e){if(e===void 0){const t=Buffer.alloc(16);return le({},t),$(ue(t.toString("hex")))}else return $(e)}const X=p.object({to:Q.refine(e=>e.toLowerCase()!==b,{message:"Cannot create payload to mint to zero address"}),price:D.default(0),currencyAddress:de.default(L),mintStartTime:Y,mintEndTime:ye,uid:p.string().optional().transform(e=>Ie(e)),primarySaleRecipient:Q.default(b)}),Re=X.extend({quantity:D}),Ve=Re.extend({mintStartTime:h,mintEndTime:h}),z=X.extend({metadata:E,royaltyRecipient:p.string().default(b),royaltyBps:me.default(0)}),F=z.extend({metadata:E.default(""),uri:p.string(),royaltyBps:h,mintStartTime:h,mintEndTime:h}),Ne=z.extend({metadata:E.default(""),quantity:q}),Je=Ne.extend({tokenId:q}),$e=F.extend({tokenId:h,quantity:h}),Qe=z.extend({metadata:E.default(""),quantity:h.default(1)}),_e=F.extend({quantity:h.default(1)}),Ge=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ye=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ze=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ke=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];export{X as B,ze as C,Ze as M,U as S,Se as a,ve as b,P as c,Ue as d,qe as e,fe as f,Je as g,$e as h,Re as i,Ve as j,Ge as k,We as l,Qe as m,De as n,_e as o,Le as p,Ye as q,Ie as r,Ke as s,je as t,He as u};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/index-4DoMYjDR.js","assets/index-rBWc323G.css"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
